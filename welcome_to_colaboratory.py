# -*- coding: utf-8 -*-
"""Welcome To Colaboratory

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb

# Enumerate
### Python’s enumerate takes a collection i.e iterable, adds counter to it and returns it as an enumerate object.[link text](https://)

##enumerate(iterable, start=0)
"""

# method 1
names = ['cars','bike','bus']
enum_names = enumerate(names)
print(list(enum_names)) 
print(type(enum_names))

# method 2
names = ['cars','bike','bus']
for i,item in enumerate(names):
  print(i,item)

"""#Map

###Map allows you to process and transform the items of the iterables or collections without using a for loop. In Python, map() function applies the given function to each item of a given iterable construct (i.e lists, tuples etc) and returns a map object.

## Syntax 
### map(function, iterable)
"""

names = ('bus', 'bike', 'cars')
total = list(map(list,names))
print(total)

"""# Comprehensions
######Comprehensions are quite popular in Python. You must have heard about list comprehensions (Python 2.0). Comprehensions in Python are the constructs that allows sequence built from other sequences and while the list comprehensions are quite popular/frequently used, Python 3.0 introduced Dictionary and set comprehensions.
"""

list_one=[15,20,25, 30,40,50,60]
new_list=[]
for x in list_one:
    new_list.append(x**3)
print(new_list)

# list comprehension 

list_two=[5,10,15,20,20,40,50,60]
new_list=[x**3 for x in list_two]
print(new_list)

#With condition
list_three=[13,20,25,45,55,65,75,85,95]
new_list=[x**3 for x in list_three if x%2==0]
print(new_list)

# Dictionary Comprehension
dict_one=[1,2,3,4]
new_dict={x: x**2 for x in dict_one if x%2==0}
print(new_dict)

""" # Examining Runtime"""

# Commented out IPython magic to ensure Python compatibility.
# %timeit range(100)

"""# Counter
#####In python, Counter is one of the high performance container data types — an unordered collection in the form of dictionary keys and values where elements are stored as keys and the counts as values.
"""

from collections import Counter
sample_list = ['a','b','c','a','a','b','c', 'd']
print(Counter(sample_list))

from collections import Counter
sample_dict =  {'a': 4, 'b': 8, 'c': 2, 'c': 6}
print(Counter(sample_dict))

"""#count ()

##Syntax 

itertools.count(start, step)

Makes an iterator that returns evenly spaced values starting with number specified with a start.
"""

import itertools
for i in itertools.count(30,4):
    print(i)
    if i > 30:
        break

"""#groupby()

To group things together just like in SQL.

## Syntax 

itertools.groupby(iterable, key=None)
"""

import itertools 
  
countries = [("West", "USA"),  
          ("West", "Canada"),  
          ("East", "Singapore"),  
          ("East", "China"), 
            ('Oceania',"Sydney")] 
  
iterator_one = itertools.groupby(countries, lambda x : x[0]) 
  
for key, group in iterator_one: 
    result = {key : list(group)} 
    print(result)

"""# Zip
In python, Zip takes one or more iterables and aggregates them into tuple and returns the iterator object.

## Syntax 
zip(*iterators)
Parameters :
Python iterables
"""

name = [ "Naina", "Tiya", "Steve", "Chard","Collin" ] 
roll_no = [ 4, 1, 3, 2,5 ] 
marks = [ 20, 40, 50, 70,90 ]
mapped = zip(name, roll_no, marks) 
mapped = set(mapped)
print (mapped)

"""#Set
In python, a set nothing but an unordered collection of items in which every element is unique and immutable.
"""

sample_set = {1,2,4,6,0,3}
sample_set.add(10)
print(sample_set)

sample_set.update([12,13])
print(sample_set)

"""#Iterators
An iterator is an object that can be iterated upon which means that you can traverse through all the values. List, tuples, dictionaries, and sets are all iterable objects.

To create an object as an iterator you have to implement the methods __iter__() and __next__() to your object where —

__iter__() returns the iterator object itself. This is used in for and in statements.

__next__() method returns the next value in the sequence. In order to avoid the iteration to go on forever, raise the StopIteration exception.
"""

class example_range:
    def __init__(self, n):
        self.i = 4
        self.n = n
    def __iter__(self):
        return self
    def __next__(self):
        if self.i < self.n:
            i = self.i
            self.i += 1
            return i
        else:
            raise StopIteration()

n= example_range(10)
list(n)

n= example_range(15)
for i in n : 
    print (i, end=',')

"""you can use an iterator for the lazy evaluation. This allows you to get the next element in the list without re-calculating all of the previous elements. Iterators can save us a lot of memory and CPU time.

Python has many built-in classes that are iterators, e.g — enumerate, map ,filer , zipand reversed etc. objects are iterators
"""



"""#Generators
Generator functions act just like regular functions with just one difference that they use the Python yieldkeyword instead of return . A generator function is a function that returns an iterator. A generator expression is an expression that returns an iterator. Generator objects are used either by calling the next method on the generator object or using the generator object in a “for in” loop.
"""

def test_sequence():
    num = 0
    while num<10:
        yield num
        num += 1
for i in test_sequence():
       print(i, end=",")

#Reverse a string
def reverse_str(test_str):
    length = len(test_str)
    for i in range(length - 1, -1, -1):
        yield test_str[i]
for char in reverse_str("Python"):
    print(char,end =" ")

"""#Generator Expression
Generator expressions can be used as the function arguments. Just like list comprehensions, generator expressions allow you to quickly create a generator object within minutes with just a few lines of code.
"""

# Initialize the list
test_list = [1, 3, 6, 10]
# list comprehension
list_comprehension = [x**3 for x in test_list]
# generator expression
test_generator = (x**3 for x in test_list)
print(list_comprehension)
print(type(test_generator))
print(tuple(test_generator))

"""The major difference between a list comprehension and a generator expression is that a list comprehension produces the entire list while the generator expression produces one item at a time as lazy evaluation.

For this reason, compared to a list comprehension, a generator expression is much more memory efficient that can be understood from profiling code.
"""

import sys
cubed_list = [i ** 3 for i in range(10000)]
print("List comprehension size(bytes):", sys.getsizeof(cubed_list))
cubed_generator = (i ** 3 for i in range(10000))
print("Generator Expression object(bytes):", sys.getsizeof(cubed_generator))

import cProfile as profiling 
#list comprehension profiling
profiling.run('sum([i ** 3 for i in range(10000)])')
#Generator Expression profiling
profiling.run('sum((i ** 3 for i in range(10000)))')

"""#Decorator
A decorator in Python is any callable Python object that is used to modify a function or a class. It takes in a function, adds some functionality, and returns it. Decorators are a very powerful and useful tool in Python since it allows programmers to modify/control the behavior of function or class. Decorators are usually called before the definition of a function you want to decorate. There are two different kinds of decorators in Python:

Function decorators

Class decorators
"""

def test_decorator(func):
    def function_wrapper(x):
        print("Before calling " + func.__name__)
        res = func(x)
        print(res)
        print("After calling " + func.__name__)
    return function_wrapper
@test_decorator
def sqr(n):
    return n ** 2
sqr(54)

"""#Multiple Decorators to a Single Function
When using Multiple Decorators to a single function, the decorators will be applied in the order they’ve been called.
"""

def lowercase_decorator(function):
    def wrapper():
        func = function()
        make_lowercase = func.lower()
        return make_lowercase
        return wrapper
def split_string(function):
    def wrapper():
        func = function()
        split_string = func.split()
        return split_string
        return wrapper
@split_string
@lowercase_decorator
def test_func():
    return 'MOTHER OF DRAGONS'
    test_func()



